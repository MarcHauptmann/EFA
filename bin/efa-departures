#!/usr/bin/perl

use EFA;
use EFA::DB;
use POSIX;
use DateTime;
use Text::Table;
use Getopt::Long;
use Pod::Usage;
use strict;
use warnings;
use utf8;

binmode(STDOUT, ":utf8");

our $num = 10;
our $time = DateTime->now(time_zone => "local");
our @departures = ();

# Setzt das Datum für die Abfrage
sub set_date {
  my $date_str = $_[1];

  $date_str =~ /(\d\d?).(\d\d?).(\d\d\d\d)/;

  $time->set(day => $1, month => $2, year => $3);
}

# Setzt die Zeit für die Abfrage
sub set_time {
  my $time_str = $_[1];

  $time_str =~ /(\d\d?):(\d\d?)/;

  $time->set(hour => $1, minute => $2);
}

# Hilfe anzeigen und beenden
sub show_help {
  pod2usage(verbose => 99,
            sections => [ qw(SYNOPSIS COMMANDS) ]);
}

# Zeigt die Abfahren an
sub add_departures {
  push @departures, get_departures($_[0],
                                   time => $time,
                                   num => $num);
}

sub show_departures {
  # Abfahrten sortieren
  my @d = sort {$a->get_time <=> $b->get_time} @departures;

  # maximal $num-viele Abfahrten ausgeben
  my $table = Text::Table->new("Minuten", "Haltestelle", "Typ", "Linie", "Ziel");

  my $end = $num - 1;

  if ($end > scalar(@d)) {
    $end = scalar(@d) - 1;
  }

  if ($end > 0) {
    for my $line (@d[0..$end]) {
      $table->add($line->get_wait_str(),
                  $line->get_station(),
                  $line->get_type(),
                  $line->get_line(),
                  $line->get_destination());
    }

    print $table->title;
    print $table->rule("-");
    print $table->body;
  } else {
    print "keine Abfahrten in der Datenbank vorhanden";
  }
}

sub query_departures {
  # Optionen verabeiten
  GetOptions("<>" => \&add_departures,
             "num|n=i" => \$num,
             "date|d=s" => \&set_date,
             "time|t=s" => \&set_time,
             "help" => \&show_help);

  show_departures();
}

sub fetch_departures {
  GetOptions("<>" => \&add_departures,
             "help" => \&show_help);

  my $num = 0;

  # alle speichern
  foreach my $departure (@departures) {
    if (!departure_is_persistent(\$departure)) {
      store_departure(\$departure);
      $num++;
    }
  }

  print "$num neue Abfahrten gespeichert\n";
}

sub list_departures {
  push @departures, load_departures(after => DateTime->now());

  show_departures();
}

sub clear_departures {
  delete_departures();
}

sub main {
  init_db();

  my %commands = ( query => \&query_departures,
                   fetch => \&fetch_departures,
                   list => \&list_departures,
                   clear => \&clear_departures);

  my $command = shift @ARGV;

  if (defined $commands{$command}) {
    &{$commands{$command}}();
  } else {
    print "unbekanntes Kommando: $command\n";

    show_help();
  }

  close_db();
}

main();

__END__

=encoding utf8

=head1 NAME

B<efa-departures> - Verwaltet die Abfahrten

=head1 SYNOPSIS

=over 8

=item I<efa-deparures query> [OPTIONS] <id>

=back

=head1 COMMANDS

=head2 clear

Löscht alle Abfahrten aus der lokalen Datenbank.

=head2 fetch <id>

Lädt alle Abfahrten und speichert sie in der lokalen Datenbank.

=head2 list

Listet die nächsten Abfahren in der Lokalen Datenbank auf. 

=head2 query [OPTIONS] <id>

ID der Station für die der die nächsten Abfahrten angezeigt werden sollen. Hier
kann auch eine Liste für mehrere Haltestellen angegeben werden.

=over 8

=back

=head3 Optionen

=over 8

=item B<--num> I<n>, B<-n> I<n>

Frage die nächsten I<n> Abfahrten ab

=item B<--date> I<date>, B<-d> I<date>

Setzt das Datum für die Abfrage auf das übergebene I<date>. Beispeil: "14.2.2012".

=item B<--time> I<time>, B<-t> I<time>

Setzt die Uhrzeit für die Abfrage. Beispiel: "03:14"

=item B<--help>

Zeigt diese Hilfe an.

=back

